/**
 * üöó OBD SaaS Server - Main Entry Point
 * 
 * Serveur moderne pour g√©rer plusieurs bo√Ætiers OBD NR-B80 en SaaS
 * Auteur: Cheikhouna FALL
 */

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const rateLimit = require('express-rate-limit');
const { createServer } = require('http');
const { Server } = require('socket.io');

// Import modules personnalis√©s
const logger = require('./src/utils/logger');
const { supabase, isLocal } = require('./src/database/supabase');
const tcpServer = require('./src/tcp/tcpServer');
const apiRoutes = require('./src/api/routes');
const { authenticateToken } = require('./src/middleware/auth');

// Configuration
const PORT = process.env.PORT || 3000;
const TCP_PORT = process.env.TCP_PORT || 6909;

class OBDSaaSServer {
    constructor() {
        this.app = express();
        this.server = createServer(this.app);
        this.io = new Server(this.server, {
            cors: {
                origin: process.env.SOCKET_CORS_ORIGIN || "http://localhost:3001",
                methods: ["GET", "POST"]
            }
        });
        this.activeConnections = new Map(); // Stockage des connexions OBD actives
        this.setupMiddleware();
        this.setupRoutes();
        this.setupWebSocket();
    }

    setupMiddleware() {
        // S√©curit√©
        this.app.use(helmet({
            contentSecurityPolicy: {
                directives: {
                    defaultSrc: ["'self'"],
                    scriptSrc: ["'self'", "'unsafe-inline'"],
                    styleSrc: ["'self'", "'unsafe-inline'"],
                    imgSrc: ["'self'", "data:", "https:"]
                }
            }
        }));

        // CORS
        this.app.use(cors({
            origin: process.env.CORS_ORIGIN || "http://localhost:3001",
            credentials: true,
            methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
            allowedHeaders: ["Content-Type", "Authorization"]
        }));

        // Compression
        this.app.use(compression());

        // Rate limiting
        const limiter = rateLimit({
            windowMs: parseInt(process.env.RATE_LIMIT_WINDOW || '15') * 60 * 1000, // 15 minutes
            max: parseInt(process.env.RATE_LIMIT_MAX || '100'), // limite par IP
            message: {
                error: 'Trop de requ√™tes, r√©essayez plus tard',
                retryAfter: '15 minutes'
            },
            standardHeaders: true,
            legacyHeaders: false
        });

        this.app.use('/api/', limiter);

        // Parsing JSON
        this.app.use(express.json({ limit: '10mb' }));
        this.app.use(express.urlencoded({ extended: true, limit: '10mb' }));

        // Logging des requ√™tes
        this.app.use((req, res, next) => {
            const start = Date.now();
            res.on('finish', () => {
                const duration = Date.now() - start;
                logger.info(`${req.method} ${req.path} - ${res.statusCode} (${duration}ms)`);
            });
            next();
        });
    }

    setupRoutes() {
        // Route de sant√©
        this.app.get('/health', (req, res) => {
            const dbStats = supabase.getStats();
            res.json({
                status: 'healthy',
                timestamp: new Date().toISOString(),
                server: {
                    uptime: process.uptime(),
                    memory: process.memoryUsage(),
                    version: process.version
                },
                database: {
                    type: isLocal() ? 'local' : 'supabase',
                    ...dbStats
                },
                tcp: {
                    port: TCP_PORT,
                    activeConnections: this.activeConnections.size
                },
                websocket: {
                    connected: this.io.engine.clientsCount
                }
            });
        });

        // Documentation API
        this.app.get('/', (req, res) => {
            res.json({
                name: 'OBD SaaS Server',
                version: '1.0.0',
                description: 'Serveur SaaS pour bo√Ætiers OBD NR-B80',
                author: 'Cheikhouna FALL',
                endpoints: {
                    health: '/health',
                    api: '/api/*',
                    docs: '/'
                },
                database: isLocal() ? 'Local (en m√©moire)' : 'Supabase',
                tcpPort: TCP_PORT,
                webSocketEnabled: true
            });
        });

        // Routes API
        this.app.use('/api', apiRoutes);

        // Gestion des erreurs 404
        this.app.use('*', (req, res) => {
            res.status(404).json({
                error: 'Route non trouv√©e',
                path: req.originalUrl,
                method: req.method,
                timestamp: new Date().toISOString()
            });
        });

        // Gestion d'erreurs globales
        this.app.use((error, req, res, next) => {
            logger.error('Erreur serveur:', error);
            res.status(500).json({
                error: 'Erreur serveur interne',
                message: process.env.NODE_ENV === 'development' ? error.message : undefined,
                timestamp: new Date().toISOString()
            });
        });
    }

    setupWebSocket() {
        // Middleware d'authentification WebSocket
        this.io.use(async (socket, next) => {
            try {
                const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.split(' ')[1];
                
                if (!token) {
                    return next(new Error('Token d\'authentification requis'));
                }

                // TODO: V√©rifier le token JWT ici
                // Pour l'instant, on accepte tous les tokens pour les tests
                socket.userId = 'user123';
                socket.organizationId = 'org123';
                
                next();
            } catch (error) {
                next(new Error('Token invalide'));
            }
        });

        // Gestion des connexions WebSocket
        this.io.on('connection', (socket) => {
            logger.info(`WebSocket connect√©: ${socket.id} (User: ${socket.userId})`);

            // Rejoindre la salle de l'organisation
            socket.join(`org_${socket.organizationId}`);

            // Envoyer les statistiques initiales
            socket.emit('initial-data', {
                connected: true,
                organizationId: socket.organizationId,
                serverTime: new Date().toISOString()
            });

            // Gestion de la d√©connexion
            socket.on('disconnect', () => {
                logger.info(`WebSocket d√©connect√©: ${socket.id}`);
            });

            // √âv√©nements personnalis√©s
            socket.on('subscribe-device', (deviceId) => {
                socket.join(`device_${deviceId}`);
                logger.info(`Client ${socket.id} abonn√© aux donn√©es de l'appareil ${deviceId}`);
            });

            socket.on('unsubscribe-device', (deviceId) => {
                socket.leave(`device_${deviceId}`);
                logger.info(`Client ${socket.id} d√©sabonn√© de l'appareil ${deviceId}`);
            });
        });
    }

    async start() {
        try {
            // Afficher le mode de base de donn√©es
            if (isLocal()) {
                logger.info('üè† Mode Base de Donn√©es: LOCALE (en m√©moire)');
                logger.info('üí° Pour utiliser Supabase, configurez SUPABASE_URL et SUPABASE_SERVICE_KEY dans .env');
            } else {
                logger.info('‚òÅÔ∏è Mode Base de Donn√©es: SUPABASE');
            }

            // D√©marrer le serveur TCP OBD
            logger.info(`üîå D√©marrage serveur TCP OBD sur port ${TCP_PORT}...`);
            await tcpServer.start(TCP_PORT, this.io);
            logger.info(`‚úÖ Serveur TCP OBD d√©marr√© sur port ${TCP_PORT}`);

            // D√©marrer le serveur HTTP/WebSocket
            this.server.listen(PORT, () => {
                logger.info(`üöÄ Serveur OBD SaaS d√©marr√© sur port ${PORT}`);
                logger.info(`üì° WebSocket activ√© sur port ${PORT}`);
                logger.info(`üåê API disponible sur http://localhost:${PORT}/api`);
                logger.info(`‚ù§Ô∏è Health check: http://localhost:${PORT}/health`);
                
                console.log('\nüéâ SERVEUR OBD SAAS PR√äT !');
                console.log(`üìä Dashboard: http://localhost:${PORT}`);
                console.log(`üîó TCP OBD: localhost:${TCP_PORT}`);
                console.log(`üíæ Base de donn√©es: ${isLocal() ? 'Locale' : 'Supabase'}`);
            });

            // Gestion de l'arr√™t propre
            this.setupGracefulShutdown();

        } catch (error) {
            logger.error('‚ùå Erreur d√©marrage serveur:', error);
            process.exit(1);
        }
    }

    setupGracefulShutdown() {
        const gracefulShutdown = async (signal) => {
            logger.info(`üì§ Signal ${signal} re√ßu, arr√™t en cours...`);
            
            try {
                // Fermer les connexions WebSocket
                this.io.close();
                
                // Arr√™ter le serveur TCP
                await tcpServer.stop();
                
                // Fermer le serveur HTTP
                this.server.close(() => {
                    logger.info('‚úÖ Serveur arr√™t√© proprement');
                    process.exit(0);
                });
                
                // Force l'arr√™t apr√®s 30 secondes
                setTimeout(() => {
                    logger.warn('‚ö†Ô∏è Arr√™t forc√© apr√®s timeout');
                    process.exit(1);
                }, 30000);
                
            } catch (error) {
                logger.error('‚ùå Erreur lors de l\'arr√™t:', error);
                process.exit(1);
            }
        };

        // G√©rer les signaux d'arr√™t
        process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
        process.on('SIGINT', () => gracefulShutdown('SIGINT'));
        
        // G√©rer les erreurs non captur√©es
        process.on('uncaughtException', (error) => {
            logger.error('‚ùå Exception non g√©r√©e:', error);
            gracefulShutdown('uncaughtException');
        });
        
        process.on('unhandledRejection', (reason, promise) => {
            logger.error('‚ùå Promesse rejet√©e non g√©r√©e:', { reason, promise });
            gracefulShutdown('unhandledRejection');
        });
    }
}

// D√©marrage du serveur
const server = new OBDSaaSServer();
server.start().catch(error => {
    logger.error('‚ùå √âchec d√©marrage serveur:', error);
    process.exit(1);
}); 